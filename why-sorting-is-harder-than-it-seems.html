<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Why sorting is harder than it seems</title><meta name="description" content="This story is about sorting arrays. I am telling it because sorting continues to surprise me with delightful bugs. Frustrating too, but also delightful. First, some context..."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://mill.plainopen.com/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://mill.plainopen.com/why-sorting-is-harder-than-it-seems.html"><link rel="alternate" type="application/atom+xml" href="https://mill.plainopen.com/feed.xml"><link rel="alternate" type="application/json" href="https://mill.plainopen.com/feed.json"><meta property="og:title" content="Why sorting is harder than it seems"><meta property="og:site_name" content="The Mill"><meta property="og:description" content="This story is about sorting arrays. I am telling it because sorting continues to surprise me with delightful bugs. Frustrating too, but also delightful. First, some context..."><meta property="og:url" content="https://mill.plainopen.com/why-sorting-is-harder-than-it-seems.html"><meta property="og:type" content="article"><link rel="preload" href="https://mill.plainopen.com/assets/dynamic/fonts/lora/lora.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="https://mill.plainopen.com/assets/dynamic/fonts/lora/lora-italic.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://mill.plainopen.com/assets/css/style.css?v=f0a2027f20f8313aca5b19cca4835a56"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://mill.plainopen.com/why-sorting-is-harder-than-it-seems.html"},"headline":"Why sorting is harder than it seems","datePublished":"2025-01-27T16:44-05:00","dateModified":"2025-01-28T18:01-05:00","description":"This story is about sorting arrays. I am telling it because sorting continues to surprise me with delightful bugs. Frustrating too, but also delightful. First, some context...","author":{"@type":"Person","name":"Dmitry Sagalovskiy","url":"https://mill.plainopen.com/authors/dmitry/"},"publisher":{"@type":"Organization","name":"Dmitry Sagalovskiy"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://mill.plainopen.com/">The Mill</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Why sorting is harder than it seems</h1><div class="feed__meta content__meta"><img src="https://mill.plainopen.com/media/website/dmitry_med-copy.jpg" loading="eager" height="1230" width="1230" class="feed__author-thumb" alt=""> <a href="https://mill.plainopen.com/authors/dmitry/" class="feed__author">Dmitry Sagalovskiy</a> <time datetime="2025-01-27T16:44" class="feed__date">2025-01-27 </time>&nbsp; @ &nbsp; <a href="https://mill.plainopen.com/">The Mill</a></div></div></header></div><div class="entry-wrapper content__entry"><p class="msg--highlight msg msg--info">Appeared originally at <a href="https://www.getgrist.com/blog/why-sorting-is-harder-than-it-seems/">https://www.getgrist.com/blog/why-sorting-is-harder-than-it-seems/</a> on 2023-02-09.</p><p>This story is about sorting arrays. I am telling it because sorting continues to surprise me with delightful bugs. Frustrating too, but also delightful.</p><p>First, some context. I’ve been working for years on a spreadsheet-database tool called <a href="https://www.getgrist.com/">Grist</a>. Naturally, it lets users sort data. There are some complications, such as letting users sort by multiple columns. Also, a column may contain different types of values: for instance, mostly numbers but with some cells that are empty or that contain a string like “N/A” or “TBD”.</p><p>Normally, sorting happens in Javascript, on data that’s already in the browser. So this post is mainly about sorting in Javascript, although the most important points are not language-specific.</p><h3 id="h-default-javascript-sort">Default JavaScript Sort</h3><p>We don’t need a complex example to start scratching our heads:</p><pre class="language-javascript"><code>[10, 2, 'x'].sort() // -&gt; produces [ 10, 2, 'x' ]</code></pre><p>This should not surprise you. We didn’t really say what we expect from mixing strings and numbers. Should <code>'a'</code> come before <code>2</code> or after? Well, Javascript has a particular answer for us: it always sorts all items as strings. The result we see is alphabetically sorted, according to the order we’d get from converting each item to a string.</p><p>This is bad for a spreadsheet. We <em>really</em> expect 2 to come before 10.</p><h3 id="h-comparators">Comparators</h3><p>Luckily, Javascript gives us a way to fix this: pass in a <em>comparator</em> function that defines the sort order <a href="#fn1"><sup>(1)</sup></a>. Javascript expects this function to take two values, say, <code>a</code> and <code>b</code>, and return something negative when <code>a &lt; b</code>, something positive when <code>a &gt; b</code>, and 0 when <code>a</code> and <code>b</code> should be considered equivalent.</p><p>Most instructions for using <code>sort()</code> provide a helpful comparator function for sorting numbers:</p><pre class="language-javascript"><code>function compareNumbers(a, b) {  return a - b;}</code></pre><p>Indeed, it satisfies the requirements: the returned value is negative, positive, or zero in all the right cases. Let’s give it a try:</p><pre class="language-javascript"><code>[10, 2, 'x' ].sort(compareNumbers)     // -&gt; produces [ 2, 10, 'x' ]</code></pre><p>Whew, you sigh! This looks correct, and was easy enough. Right? No, this would be too easy. Look at the result if we reverse two values in the original array:</p><pre class="language-javascript"><code>[10, 'x' , 2].sort(compareNumbers)     // -&gt; produces [ 10, 'x', 2 ]</code></pre><p>This is not at all correct. It is even more upsetting that it’s even possible to get different answers.</p><p>Let’s think why this happened? Well, our comparator’s key operation is <code>a - b</code>. It makes sense for numbers, but not for the string <code>'x'</code>. In fact, when comparing a number to a string, it returns <code>NaN</code>. Maybe that’s the problem. We were told to return positive, negative, or 0, not <code>NaN</code>.</p><p>Let’s fix our comparator function. Here is a versatile one:</p><pre class="language-javascript"><code>function nativeCompare(a, b) {
  return (a &lt; b ? -1 : (a &gt; b ? 1 : 0));
}</code></pre><p>In fact, it’s used a lot in Grist. It’s perfectly valid to compare <code>'x' &lt; 2</code>, there is no exception, and we always return a valid comparator value: never <code>NaN</code>. This one has got to work. Right?</p><pre class="language-javascript"><code>[10, 2, 'x'].sort(nativeCompare)     // -&gt; [ 2, 10, 'x' ]
[10, 'x', 2].sort(nativeCompare)     // -&gt; [ 10, 'x', 2 ]</code></pre><p>No, don’t tell me. The same exact terrible result as last time.</p><h3 id="h-transitivity">Transitivity</h3><p>If you read far enough in the documentation of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description" target="_blank" rel="noreferrer noopener">sort on MDN</a>, you’ll find some more requirements that the comparator function needs to fulfill. Let’s see how our <code>nativeCompare</code> does on these requirements:</p><ul><li>✔️ It is <em>pure</em>: no side-effects of calling it.</li><li>✔️ It is <em>stable</em>: it returns the same result for the same inputs.</li><li>✔️ It is <em>reflexive</em>: it returns 0 when called with two of the same value (certainly for the values in our example).</li><li>❓ Is it <em>anti-symmetric</em>? Calling it for (a, b) or (b, a) should produce opposite signs. We should check.</li><li>❓ Is it <em>transitive</em>? If a &lt; b and b &lt; c, does it guarantee a &lt; c? We should check.</li></ul><p>These form the definition of something called a <em>strict weak order </em><sup><a href="#fn2">(2)</a></sup>. All that means is that “the order makes sense”. The fact that it’s not an obvious thing is what makes sorting bugs fun (and frustrating).</p><p>Our <code>nativeCompare</code> function really just repackages the behavior of the standard Javascript “less-than” and “greater-than” operators. Do those define an order that makes sense?</p><p>These operators are described in great detail here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Less_than" target="_blank" rel="noreferrer noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Less_than</a>. Good luck figuring out what to expect. To save you some work, no, they do not define an order that “makes sense”. That’s because:</p><pre class="language-javascript"><code>  1 &lt; "2"  // true
"2" &lt; "a"  // true
  1 &lt; "a"  // false; broken transitivity!</code></pre><p>Or with the values from our example:</p><pre class="language-javascript"><code>  2 &lt; 'x'  // false
'x' &lt; 10   // false
  2 &lt; 10   // true</code></pre><p>This is a fail. By the standard of “makes sense”, the first two say that <code>2 &gt;= 'x'</code> and <code>'x' &gt;= 10</code>, and the third says <code>2 &lt; 10</code>, the opposite of what transitivity <em>should</em> give us.</p><p>Translating it to <code>nativeCompare</code> makes this a bit more precise:</p><pre class="language-javascript"><code>nativeCompare(2, 'x')    // 0 (they are "equivalent")
nativeCompare('x', 10)   // 0 (they are "equivalent")
nativeCompare(2, 10)     // -1 (doh!)</code></pre><p>This is a fail of transitivity.</p><h3 id="h-but-why-is-sort-so-fickle">But why is sort so fickle?</h3><p>At this point, maybe it’s good to step back and say: transitivity-shmansitivity. All the operations are clearly correct for numbers. If we throw a string into the mix, we don’t really care if it ends up at the start or at the end. But why does it affect the relative order of the numbers? And why the inconsistency?</p><p>To answer that, we need to remember the sorting algorithms. That’s a lovely topic. I remember learning them in AP Computer Science in high school, and in algorithms class in college. These days, there is little <em>need</em> to know them: every modern language has an efficient sorting function or method readily available. But there is satisfaction in understanding them, because they are beautiful gems of insight. <sup><a href="#fn3">(3)</a></sup></p><p>What’s worth remembering is that these are algorithms based on comparisons. They are fast because they minimize the number of comparisons. The efficient algorithms (including all the built-in implementations) make <em>O(N log N)</em> comparisons. This means that are optimally economical with comparisons.</p><p>Why does it matter? Because if the algorithm has already noticed that <code>2</code> is “equivalent” to <code>'x'</code>, and that <code>'x'</code> is “equivalent” to <code>10</code>, then it’s not going to compare <code>2</code> and <code>10</code> at all. Transitivity, remember? It already knows that <code>2</code> is “equivalent” to <code>10</code>, without making the direct comparison.</p><p>Think of binary search for a simpler example: you start by comparing a value to one in the middle of a sorted array. This single comparison determines which half to limit the rest of the search to. You’ll never compare your value to anything in the other half. You don’t have to because of transitivity.</p><p>In short, with sorting, each comparison affects the result. So even a single violation of transitivity means that all bets are off. You <em>will</em> (guaranteed) find cases when your sort result is wrong.</p><h3 id="h-i-will-have-order">“I will have order!”</h3><figure class="post__image"><img loading="lazy" src="https://mill.plainopen.com/media/posts/1/harry-potter-imelda-staunton-2.gif" alt="" width="498" height="205"></figure><p>The only way to fix it is to fix transitivity and anti-symmetry.</p><p>The basic idea is this:</p><pre class="language-javascript"><code>function typedCompare(a, b) {
   return nativeCompare(typeof a, typeof b) || nativeCompare(a, b);
}</code></pre><p>The <code>||</code> operator is a shorthand for saying: return the value on the left, but when it’s 0, then return the one on the right. The left part compares types (e.g. <code>typeof 2</code> is <code>"number"</code>). If they are not equal, they determine the order of the values. So all numbers come before all strings (because <code>"number" &lt; "string"</code>). When types are equal, then we compare the values themselves. Comparisons actually are consistent when applied only to strings. They are also consistent when applied only to normal numbers (not <code>NaN</code> or <code>Infinity</code> though). So this solution will in fact work for any mix of strings and normal numbers:</p><pre class="language-javascript"><code>[10, 2, 'x'].sort(typedCompare)     // -&gt; [ 2, 10, 'x' ]
[10, 'x', 2].sort(typedCompare)     // -&gt; [ 2, 10, 'x' ]</code></pre><p>Grist has to deal with other values, like arrays, and with other sort options, like ascending / descending, “natural sort”, and “empty values last” option. Grist is open-source so you can find all this fancy logic written in code here: <a href="https://github.com/gristlabs/grist-core/blob/main/app/common/SortFunc.ts" target="_blank" rel="noreferrer noopener">https://github.com/gristlabs/grist-core/blob/main/app/common/SortFunc.ts</a>.</p><h3 id="h-ok-done-yet">OK, done yet?</h3><p>When I said sorting continues to surprise me, I meant it.</p><p>The other day Grist had a fix landed for another sorting bug. For sorting empty values last, it had the following comparator function (simplified a bit for clarity):</p><pre class="language-javascript"><code>function emptyCompareBad(a, b) {
  if (isEmpty(a)) {
    return 1;
  }
  if (isEmpty(b)) {
    return -1;
  }
  return 0;
}</code></pre><p>The idea is straightforward: if <code>a</code> is empty, we compare a as “greater” than <code>b</code>, to sort after it (right?). Otherwise, we look at <code>b</code>. If that’s empty, we compare <code>a</code> as “less” than <code>b</code>. Otherwise, they are equivalent, as far as their emptiness is concerned.</p><p>No, in fact, this code was buggy. Here’s the fixed version. See if you can tell when it’s different:</p><pre class="language-javascript"><code>function emptyCompareGood(a, b) {
  return nativeCompare(isEmpty(a), isEmpty(b));
}

// Recall what nativeCompare() is:
function nativeCompare(a, b) {
  return (a &lt; b ? -1 : (a &gt; b ? 1 : 0));
}</code></pre><p>Are these versions equivalent? Sometimes yes, but not if both <code>a</code> and <code>b</code> are empty. In that case, the comparator <em>should</em> return 0 to indicate equivalence, but the bad version was returning 1. Does that break transitivity? No, actually (at least I haven’t found that), but it breaks the <em>reflexive</em> and <em>anti-symmetric</em> properties. Ultimately, the bug showed up in combination with other comparators.</p><p>Sorting in Grist is not perfect in other ways either. For instance, the values <code>NaN</code> and <code>Infinity</code> have the type <code>'number'</code> but don’t get checked specially. The only reason that’s not a visible bug in Grist is that these are rarely used and not really supported as cell values. But if you do manage to include them in a Grist document (e.g. as formula return values), you can easily recreate a sorting bug like the ones covered in this post.</p><h3 id="h-in-conclusion">In conclusion</h3><p>Sorting in Javascript requires a <em>suitable</em> comparator. It is science, not art. You have to pay attention to the types you need to support. My recommendation is to stitch the comparator out of simpler comparators that you can have confidence in: the first one to return a non-zero value should win.</p><p>If you make a mistake, it virtually guarantees that some arrays will sort incorrectly.</p><p>All this is not actually specific to Javascript <sup><a href="#fn4">(4)</a></sup>. It’s a general observation of sorting. If your values are a single type, then there is probably a suitable comparator you can already use. When you have to create a comparator of your own, all these lessons apply.</p><hr><p id="fn1" class="footnote">(1) There are several equivalent ways to define a sort order: C++ <a href="https://cplusplus.com/reference/algorithm/sort/" target="_blank" rel="noreferrer noopener">standard library sort</a> favors a function like “less than” (which return true or false), while Javascript and Python favor “comparator” (which returns negative, positive, or 0 to indicate “less-than”, “greater-than”, or “equivalent”).</p><p id="fn2" class="footnote">(2) I’ll link to Wikipedia article <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings" target="_blank" rel="noreferrer noopener">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> but it looks painful to read even for an enthusiastic theoretical math major.</p><p id="fn3" class="footnote">(3) The value in understanding algorithms is similar to the value in understanding the Pythagorean Theorem (and why it’s true), or understanding why we have seasons on this Earth. Not necessary, but satisfying.</p><p class="footnote">(4) Some reactions to this post assumed Javascript is at fault. For string-number conversions, it is, but for all the sorting points, it's not. You'll get the same problems in any language if using an inconsistent comparator, for example when sorting an array of numbers that include NaNs. For example, in Python3, <code>sorted([10, math.nan, 2])</code>  produces <code>[10, nan, 2]</code>). In C++, <code>double arr[] = {5, NAN, 2, 10}; std::sort(arr, arr + 4);</code> produces <code>{2, nan, 10, 5}</code>.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on 2025-01-28</p><div class="content__actions"><ul class="content__tag"><li><a href="https://mill.plainopen.com/tags/algorithms/">algorithms</a></li><li><a href="https://mill.plainopen.com/tags/computer-science/">computer science</a></li><li><a href="https://mill.plainopen.com/tags/education/">education</a></li><li><a href="https://mill.plainopen.com/tags/javascript/">javascript</a></li><li><a href="https://mill.plainopen.com/tags/math/">math</a></li></ul><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://mill.plainopen.com/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fmill.plainopen.com%2Fwhy-sorting-is-harder-than-it-seems.html" class="js-share linkedin" rel="nofollow noopener noreferrer"><svg class="icon" aria-hidden="true" focusable="false"><use xlink:href="https://mill.plainopen.com/assets/svg/svg-map.svg#linkedin"/></svg> <span>LinkedIn</span></a></div></div></div></div></footer></article><div class="banner banner--after-content"><div class="wrapper"><script src="https://giscus.app/client.js" data-repo="dsagal/plainopen-mill-blog" data-repo-id="R_kgDONwenRg" data-category="Announcements" data-category-id="DIC_kwDONwenRs4CmbOd" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="1" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="en" crossorigin="anonymous" async></script><div id="giscus-alternative" style="display: none">Instead of signing in here, you can comment directly <a href="" id="giscus-discussion-link">on GitHub</a>.</div><script>window.addEventListener('message', event => {
    if (event.origin !== 'https://giscus.app') { return; }
    const discussionUrl = event.data?.giscus?.discussion?.url;
    if (!discussionUrl) { return; }
    const altElem = document.querySelector('#giscus-alternative');
    const linkElem = document.querySelector('#giscus-discussion-link');
    if (!altElem || !linkElem) { return; }
    linkElem.href = discussionUrl;
    altElem.style.display = '';
});</script></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>© 2025 The Mill — <a href="https://github.com/dsagal/">GitHub</a> — <a href="https://www.linkedin.com/in/dsagal/">LinkedIn</a></p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://mill.plainopen.com/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://mill.plainopen.com/assets/js/scripts.min.js?v=ffcbea6c02c8178d10092962b235a5b0"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://mill.plainopen.com/media/plugins/syntaxHighlighter/prism.js"></script></body></html>